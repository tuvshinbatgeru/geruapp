["5e495d40fc8d7f7211d9777c90f8a14f18020756","1d038fd01c650fa04aee73e78d3b20701fc44a94",["EventEmitter","NativeEventEmitter","NativeModules","logError","fbjs/lib/invariant"],[43,93,144,228,265],{"version":3,"sources":["/var/www/geruapp/node_modules/react-native/Libraries/AppState/AppState.js"],"names":["EventEmitter","require","NativeEventEmitter","NativeModules","RCTAppState","AppState","logError","invariant","isAvailable","_eventHandlers","change","Map","memoryWarning","currentState","initialAppState","addListener","appStateData","app_state","getCurrentAppState","type","handler","indexOf","set","has","get","remove","delete","throwMissingNativeModule","MissingNativeAppStateShim","module","exports"],"mappings":";AAWA;;AAEA,IAAMA,eAAeC,QAAQ,cAAR,CAArB;AACA,IAAMC,qBAAqBD,QAAQ,oBAAR,CAA3B;AACA,IAAME,gBAAgBF,QAAQ,eAAR,CAAtB;AACA,IAAMG,cAAcD,cAAcE,QAAlC;;AAEA,IAAMC,WAAWL,QAAQ,UAAR,CAAjB;AACA,IAAMM,YAAYN,QAAQ,oBAAR,CAAlB;;IAkEMI,Q;;;AAMJ,sBAAc;AAAA;;AAAA,gIACND,WADM;;AAGZ,UAAKI,WAAL,GAAmB,IAAnB;AACA,UAAKC,cAAL,GAAsB;AACpBC,cAAQ,IAAIC,GAAJ,EADY;AAEpBC,qBAAe,IAAID,GAAJ;AAFK,KAAtB;;AAOA,UAAKE,YAAL,GAAoBT,YAAYU,eAAZ,IAA+B,QAAnD;;AAMA,UAAKC,WAAL,CACE,mBADF,EAEE,UAACC,YAAD,EAAkB;AAChB,YAAKH,YAAL,GAAoBG,aAAaC,SAAjC;AACD,KAJH;;AAUAb,gBAAYc,kBAAZ,CACE,UAACF,YAAD,EAAkB;AAChB,YAAKH,YAAL,GAAoBG,aAAaC,SAAjC;AACD,KAHH,EAIEX,QAJF;AA3BY;AAiCb;;;;qCAaCa,I,EACAC,O,EACA;AACAb,gBACE,CAAC,QAAD,EAAW,eAAX,EAA4Bc,OAA5B,CAAoCF,IAApC,MAA8C,CAAC,CADjD,EAEE,4CAFF,EAEgDA,IAFhD;AAIA,UAAIA,SAAS,QAAb,EAAuB;AACrB,aAAKV,cAAL,CAAoBU,IAApB,EAA0BG,GAA1B,CAA8BF,OAA9B,EAAuC,KAAKL,WAAL,CACrC,mBADqC,EAErC,UAACC,YAAD,EAAkB;AAChBI,kBAAQJ,aAAaC,SAArB;AACD,SAJoC,CAAvC;AAMD,OAPD,MAOO,IAAIE,SAAS,eAAb,EAA8B;AACnC,aAAKV,cAAL,CAAoBU,IAApB,EAA0BG,GAA1B,CAA8BF,OAA9B,EAAuC,KAAKL,WAAL,CACrC,eADqC,EAErCK,OAFqC,CAAvC;AAID;AACF;;;wCAMCD,I,EACAC,O,EACA;AACAb,gBACE,CAAC,QAAD,EAAW,eAAX,EAA4Bc,OAA5B,CAAoCF,IAApC,MAA8C,CAAC,CADjD,EAEE,mDAFF,EAEuDA,IAFvD;AAIA,UAAI,CAAC,KAAKV,cAAL,CAAoBU,IAApB,EAA0BI,GAA1B,CAA8BH,OAA9B,CAAL,EAA6C;AAC3C;AACD;AACD,WAAKX,cAAL,CAAoBU,IAApB,EAA0BK,GAA1B,CAA8BJ,OAA9B,EAAuCK,MAAvC;AACA,WAAKhB,cAAL,CAAoBU,IAApB,EAA0BO,MAA1B,CAAiCN,OAAjC;AACD;;;EA1FoBlB,kB;;AA6FvB,SAASyB,wBAAT,GAAoC;AAClCpB,YACE,KADF,EAEE,uFACA,8EAHF;AAKD;;IAEKqB,yB;;;;;;;;;;;;;;2OAEJpB,W,GAAuB,K,SACvBK,Y,GAAwB,I;;;;;uCAEL;AACjBc;AACD;;;0CAEqB;AACpBA;AACD;;;kCAGa;AACZA;AACD;;;yCAEoB;AACnBA;AACD;;;yCAEoB;AACnBA;AACD;;;EAxBqC3B,Y;;AA8BxC,IAAII,WAAJ,EAAiB;AACfC,aAAW,IAAIA,QAAJ,EAAX;AACD,CAFD,MAEO;AACLA,aAAW,IAAIuB,yBAAJ,EAAX;AACD;;AAEDC,OAAOC,OAAP,GAAiBzB,QAAjB","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule AppState\n * @flow\n */\n'use strict';\n\nconst EventEmitter = require('EventEmitter');\nconst NativeEventEmitter = require('NativeEventEmitter');\nconst NativeModules = require('NativeModules');\nconst RCTAppState = NativeModules.AppState;\n\nconst logError = require('logError');\nconst invariant = require('fbjs/lib/invariant');\n\n/**\n * `AppState` can tell you if the app is in the foreground or background,\n * and notify you when the state changes.\n *\n * AppState is frequently used to determine the intent and proper behavior when\n * handling push notifications.\n *\n * ### App States\n *\n *  - `active` - The app is running in the foreground\n *  - `background` - The app is running in the background. The user is either\n *     in another app or on the home screen\n *  - `inactive` - This is a state that occurs when transitioning between\n *  \t foreground & background, and during periods of inactivity such as\n *  \t entering the Multitasking view or in the event of an incoming call\n *\n * For more information, see\n * [Apple's documentation](https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/TheAppLifeCycle/TheAppLifeCycle.html)\n *\n * ### Basic Usage\n *\n * To see the current state, you can check `AppState.currentState`, which\n * will be kept up-to-date. However, `currentState` will be null at launch\n * while `AppState` retrieves it over the bridge.\n *\n * ```\n * import React, {Component} from 'react'\n * import {AppState, Text} from 'react-native'\n *\n * class AppStateExample extends Component {\n *\n *   state = {\n *     appState: AppState.currentState\n *   }\n *\n *   componentDidMount() {\n *     AppState.addEventListener('change', this._handleAppStateChange);\n *   }\n *\n *   componentWillUnmount() {\n *     AppState.removeEventListener('change', this._handleAppStateChange);\n *   }\n *\n *   _handleAppStateChange = (nextAppState) => {\n *     if (this.state.appState.match(/inactive|background/) && nextAppState === 'active') {\n *       console.log('App has come to the foreground!')\n *     }\n *     this.setState({appState: nextAppState});\n *   }\n *\n *   render() {\n *     return (\n *       <Text>Current state is: {this.state.appState}</Text>\n *     );\n *   }\n *\n * }\n * ```\n *\n * This example will only ever appear to say \"Current state is: active\" because\n * the app is only visible to the user when in the `active` state, and the null\n * state will happen only momentarily.\n */\n\nclass AppState extends NativeEventEmitter {\n\n  _eventHandlers: Object;\n  currentState: ?string;\n  isAvailable: boolean;\n\n  constructor() {\n    super(RCTAppState);\n\n    this.isAvailable = true;\n    this._eventHandlers = {\n      change: new Map(),\n      memoryWarning: new Map(),\n    };\n\n    // TODO: Remove the 'active' fallback after `initialAppState` is exported by\n    // the Android implementation.\n    this.currentState = RCTAppState.initialAppState || 'active';\n\n    // TODO: this is a terrible solution - in order to ensure `currentState` prop\n    // is up to date, we have to register an observer that updates it whenever\n    // the state changes, even if nobody cares. We should just deprecate the\n    // `currentState` property and get rid of this.\n    this.addListener(\n      'appStateDidChange',\n      (appStateData) => {\n        this.currentState = appStateData.app_state;\n      }\n    );\n\n    // TODO: see above - this request just populates the value of `currentState`\n    // when the module is first initialized. Would be better to get rid of the prop\n    // and expose `getCurrentAppState` method directly.\n    RCTAppState.getCurrentAppState(\n      (appStateData) => {\n        this.currentState = appStateData.app_state;\n      },\n      logError\n    );\n  }\n\n  /**\n   * Add a handler to AppState changes by listening to the `change` event type\n   * and providing the handler\n   *\n   * TODO: now that AppState is a subclass of NativeEventEmitter, we could deprecate\n   * `addEventListener` and `removeEventListener` and just use `addListener` and\n   * `listener.remove()` directly. That will be a breaking change though, as both\n   * the method and event names are different (addListener events are currently\n   * required to be globally unique).\n   */\n  addEventListener(\n    type: string,\n    handler: Function\n  ) {\n    invariant(\n      ['change', 'memoryWarning'].indexOf(type) !== -1,\n      'Trying to subscribe to unknown event: \"%s\"', type\n    );\n    if (type === 'change') {\n      this._eventHandlers[type].set(handler, this.addListener(\n        'appStateDidChange',\n        (appStateData) => {\n          handler(appStateData.app_state);\n        }\n      ));\n    } else if (type === 'memoryWarning') {\n      this._eventHandlers[type].set(handler, this.addListener(\n        'memoryWarning',\n        handler\n      ));\n    }\n  }\n\n  /**\n   * Remove a handler by passing the `change` event type and the handler\n   */\n  removeEventListener(\n    type: string,\n    handler: Function\n  ) {\n    invariant(\n      ['change', 'memoryWarning'].indexOf(type) !== -1,\n      'Trying to remove listener for unknown event: \"%s\"', type\n    );\n    if (!this._eventHandlers[type].has(handler)) {\n      return;\n    }\n    this._eventHandlers[type].get(handler).remove();\n    this._eventHandlers[type].delete(handler);\n  }\n}\n\nfunction throwMissingNativeModule() {\n  invariant(\n    false,\n    'Cannot use AppState module when native RCTAppState is not included in the build.\\n' +\n    'Either include it, or check AppState.isAvailable before calling any methods.'\n  );\n}\n\nclass MissingNativeAppStateShim extends EventEmitter {\n  // AppState\n  isAvailable: boolean = false;\n  currentState: ?string = null;\n\n  addEventListener() {\n    throwMissingNativeModule();\n  }\n\n  removeEventListener() {\n    throwMissingNativeModule();\n  }\n\n  // EventEmitter\n  addListener() {\n    throwMissingNativeModule();\n  }\n\n  removeAllListeners() {\n    throwMissingNativeModule();\n  }\n\n  removeSubscription() {\n    throwMissingNativeModule();\n  }\n}\n\n// This module depends on the native `RCTAppState` module. If you don't include it,\n// `AppState.isAvailable` will return `false`, and any method calls will throw.\n// We reassign the class variable to keep the autodoc generator happy.\nif (RCTAppState) {\n  AppState = new AppState();\n} else {\n  AppState = new MissingNativeAppStateShim();\n}\n\nmodule.exports = AppState;\n"]}]