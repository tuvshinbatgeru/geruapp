["fc82214abd5d8a7056d990a17704a3fdfa04bb59","5472942489354f0ac17e1a8ae8e9f7920ed872fc",["ReactFiberContext","ReactFiberStack","ReactFiberComponentTreeHook","ReactFiberErrorLogger","ReactErrorUtils","ReactFiberBeginWork","ReactFiberCompleteWork","ReactFiberCommitWork","ReactFiberHostContext","react/lib/ReactCurrentOwner","ReactFeatureFlags","getComponentName","ReactFiber","ReactFiberDevToolsHook","ReactPriorityLevel","ReactTypeOfSideEffect","ReactTypeOfWork","ReactFiberUpdateQueue","fbjs/lib/invariant","fbjs/lib/warning","ReactFiberInstrumentation","ReactDebugCurrentFiber","ReactDebugFiberPerf"],[40,141,215,365,467,583,644,706,767,825,889,942,988,1067,1162,1531,1904,2120,2228,2319,2382,2445,2514,2569],{"version":3,"sources":["/var/www/geruapp/node_modules/react-native/Libraries/Renderer/src/renderers/shared/fiber/ReactFiberScheduler.js"],"names":["require","popContextProvider","reset","getStackAddendumByWorkInProgressFiber","logCapturedError","invokeGuardedCallback","ReactFiberBeginWork","ReactFiberCompleteWork","ReactFiberCommitWork","ReactFiberHostContext","ReactCurrentOwner","ReactFeatureFlags","getComponentName","cloneFiber","onCommitRoot","NoWork","SynchronousPriority","TaskPriority","AnimationPriority","HighPriority","LowPriority","OffscreenPriority","NoEffect","Placement","Update","PlacementAndUpdate","Deletion","ContentReset","Callback","Err","Ref","HostRoot","HostComponent","HostPortal","ClassComponent","getPendingPriority","resetContext","invariant","__DEV__","warning","ReactFiberInstrumentation","ReactDebugCurrentFiber","recordEffect","recordScheduleUpdate","startWorkTimer","stopWorkTimer","startWorkLoopTimer","stopWorkLoopTimer","startCommitTimer","stopCommitTimer","startCommitHostEffectsTimer","stopCommitHostEffectsTimer","startCommitLifeCyclesTimer","stopCommitLifeCyclesTimer","warnAboutUpdateOnUnmounted","instance","ctor","constructor","displayName","name","warnAboutInvalidUpdates","phase","timeHeuristicForUnitOfWork","module","exports","config","hostContext","popHostContainer","popHostContext","resetHostContainer","scheduleUpdate","getPriorityContext","beginWork","beginFailedWork","completeWork","captureError","commitPlacement","commitDeletion","commitWork","commitLifeCycles","commitAttachRef","commitDetachRef","hostScheduleAnimationCallback","scheduleAnimationCallback","hostScheduleDeferredCallback","scheduleDeferredCallback","useSyncScheduling","prepareForCommit","resetAfterCommit","priorityContext","priorityContextBeforeReconciliation","isPerformingWork","deadlineHasExpired","isBatchingUpdates","nextUnitOfWork","nextPriorityLevel","nextEffect","pendingCommit","nextScheduledRoot","lastScheduledRoot","isAnimationCallbackScheduled","isDeferredCallbackScheduled","capturedErrors","failedBoundaries","commitPhaseBoundaries","firstUncaughtError","fatalError","isCommitting","isUnmounting","callback","resetContextStack","findNextUnitOfWork","current","pendingWorkPriority","isScheduled","next","root","highestPriorityRoot","highestPriorityLevel","commitAllHostEffects","effectTag","resetTextContent","stateNode","alternate","primaryEffectTag","commitAllLifeCycles","commitErrorHandling","commitAllWork","finishedWork","previousPriorityContext","firstEffect","lastEffect","commitInfo","error","e","debugTool","onCommitWork","forEach","scheduleErrorRecovery","resetWorkPriority","workInProgress","newPriority","queue","updateQueue","tag","child","progressedChild","sibling","completeUnitOfWork","returnFiber","return","siblingFiber","onCompleteWork","performUnitOfWork","onBeginWork","performFailedUnitOfWork","performDeferredWork","deadline","performWork","performAnimationWork","clearErrors","size","hasCapturedError","workLoop","priorityLevel","hostRootTimeMarker","logTopLevelRenders","componentName","console","time","timeRemaining","timeEnd","isPerformingDeferredWork","failedWork","maybeBoundary","boundary","unwindContexts","errorToThrow","errorBoundaryFound","willRetry","errorBoundaryName","isFailedBoundary","node","unstable_handleError","has","Set","add","componentStack","Map","set","errorBoundary","fiber","effectfulFiber","capturedError","get","delete","info","from","to","scheduleRoot","shouldContinue","performWithPriority","fn","batchedUpdates","a","previousIsBatchingUpdates","unbatchedUpdates","syncUpdates","deferredUpdates"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactFiberScheduler\n * @flow\n */\n\n'use strict';\n\nimport type {Fiber} from 'ReactFiber';\nimport type {FiberRoot} from 'ReactFiberRoot';\nimport type {HostConfig, Deadline} from 'ReactFiberReconciler';\nimport type {PriorityLevel} from 'ReactPriorityLevel';\n\nexport type CapturedError = {\n  componentName: ?string,\n  componentStack: string,\n  error: Error,\n  errorBoundary: ?Object,\n  errorBoundaryFound: boolean,\n  errorBoundaryName: string | null,\n  willRetry: boolean,\n};\n\nexport type HandleErrorInfo = {\n  componentStack: string,\n};\n\nvar {\n  popContextProvider,\n} = require('ReactFiberContext');\nconst {reset} = require('ReactFiberStack');\nvar {\n  getStackAddendumByWorkInProgressFiber,\n} = require('ReactFiberComponentTreeHook');\nvar {logCapturedError} = require('ReactFiberErrorLogger');\nvar {invokeGuardedCallback} = require('ReactErrorUtils');\n\nvar ReactFiberBeginWork = require('ReactFiberBeginWork');\nvar ReactFiberCompleteWork = require('ReactFiberCompleteWork');\nvar ReactFiberCommitWork = require('ReactFiberCommitWork');\nvar ReactFiberHostContext = require('ReactFiberHostContext');\nvar ReactCurrentOwner = require('react/lib/ReactCurrentOwner');\nvar ReactFeatureFlags = require('ReactFeatureFlags');\nvar getComponentName = require('getComponentName');\n\nvar {cloneFiber} = require('ReactFiber');\nvar {onCommitRoot} = require('ReactFiberDevToolsHook');\n\nvar {\n  NoWork,\n  SynchronousPriority,\n  TaskPriority,\n  AnimationPriority,\n  HighPriority,\n  LowPriority,\n  OffscreenPriority,\n} = require('ReactPriorityLevel');\n\nvar {\n  NoEffect,\n  Placement,\n  Update,\n  PlacementAndUpdate,\n  Deletion,\n  ContentReset,\n  Callback,\n  Err,\n  Ref,\n} = require('ReactTypeOfSideEffect');\n\nvar {\n  HostRoot,\n  HostComponent,\n  HostPortal,\n  ClassComponent,\n} = require('ReactTypeOfWork');\n\nvar {\n  getPendingPriority,\n} = require('ReactFiberUpdateQueue');\n\nvar {\n  resetContext,\n} = require('ReactFiberContext');\n\nvar invariant = require('fbjs/lib/invariant');\n\nif (__DEV__) {\n  var warning = require('fbjs/lib/warning');\n  var ReactFiberInstrumentation = require('ReactFiberInstrumentation');\n  var ReactDebugCurrentFiber = require('ReactDebugCurrentFiber');\n  var {\n    recordEffect,\n    recordScheduleUpdate,\n    startWorkTimer,\n    stopWorkTimer,\n    startWorkLoopTimer,\n    stopWorkLoopTimer,\n    startCommitTimer,\n    stopCommitTimer,\n    startCommitHostEffectsTimer,\n    stopCommitHostEffectsTimer,\n    startCommitLifeCyclesTimer,\n    stopCommitLifeCyclesTimer,\n  } = require('ReactDebugFiberPerf');\n\n  var warnAboutUpdateOnUnmounted = function(instance: ReactClass<any>) {\n    const ctor = instance.constructor;\n    warning(\n      false,\n      'Can only update a mounted or mounting component. This usually means ' +\n        'you called setState, replaceState, or forceUpdate on an unmounted ' +\n        'component. This is a no-op.\\n\\nPlease check the code for the ' +\n        '%s component.',\n      (ctor && (ctor.displayName || ctor.name)) || 'ReactClass',\n    );\n  };\n\n  var warnAboutInvalidUpdates = function(instance: ReactClass<any>) {\n    switch (ReactDebugCurrentFiber.phase) {\n      case 'getChildContext':\n        warning(\n          false,\n          'setState(...): Cannot call setState() inside getChildContext()',\n        );\n        break;\n      case 'render':\n        warning(\n          false,\n          'Cannot update during an existing state transition (such as within ' +\n            \"`render` or another component's constructor). Render methods should \" +\n            'be a pure function of props and state; constructor side-effects are ' +\n            'an anti-pattern, but can be moved to `componentWillMount`.',\n        );\n        break;\n    }\n  };\n}\n\nvar timeHeuristicForUnitOfWork = 1;\n\nmodule.exports = function<T, P, I, TI, PI, C, CX, PL>(\n  config: HostConfig<T, P, I, TI, PI, C, CX, PL>,\n) {\n  const hostContext = ReactFiberHostContext(config);\n  const {popHostContainer, popHostContext, resetHostContainer} = hostContext;\n  const {beginWork, beginFailedWork} = ReactFiberBeginWork(\n    config,\n    hostContext,\n    scheduleUpdate,\n    getPriorityContext,\n  );\n  const {completeWork} = ReactFiberCompleteWork(config, hostContext);\n  const {\n    commitPlacement,\n    commitDeletion,\n    commitWork,\n    commitLifeCycles,\n    commitAttachRef,\n    commitDetachRef,\n  } = ReactFiberCommitWork(config, captureError);\n  const {\n    scheduleAnimationCallback: hostScheduleAnimationCallback,\n    scheduleDeferredCallback: hostScheduleDeferredCallback,\n    useSyncScheduling,\n    prepareForCommit,\n    resetAfterCommit,\n  } = config;\n\n  // The priority level to use when scheduling an update.\n  // TODO: Should we change this to an array? Might be less confusing.\n  let priorityContext: PriorityLevel = useSyncScheduling\n    ? SynchronousPriority\n    : LowPriority;\n\n  // Keep track of this so we can reset the priority context if an error\n  // is thrown during reconciliation.\n  let priorityContextBeforeReconciliation: PriorityLevel = NoWork;\n\n  // Keeps track of whether we're currently in a work loop.\n  let isPerformingWork: boolean = false;\n\n  // Keeps track of whether the current deadline has expired.\n  let deadlineHasExpired: boolean = false;\n\n  // Keeps track of whether we should should batch sync updates.\n  let isBatchingUpdates: boolean = false;\n\n  // The next work in progress fiber that we're currently working on.\n  let nextUnitOfWork: Fiber | null = null;\n  let nextPriorityLevel: PriorityLevel = NoWork;\n\n  // The next fiber with an effect that we're currently committing.\n  let nextEffect: Fiber | null = null;\n\n  let pendingCommit: Fiber | null = null;\n\n  // Linked list of roots with scheduled work on them.\n  let nextScheduledRoot: FiberRoot | null = null;\n  let lastScheduledRoot: FiberRoot | null = null;\n\n  // Keep track of which host environment callbacks are scheduled.\n  let isAnimationCallbackScheduled: boolean = false;\n  let isDeferredCallbackScheduled: boolean = false;\n\n  // Keep track of which fibers have captured an error that need to be handled.\n  // Work is removed from this collection after unstable_handleError is called.\n  let capturedErrors: Map<Fiber, CapturedError> | null = null;\n  // Keep track of which fibers have failed during the current batch of work.\n  // This is a different set than capturedErrors, because it is not reset until\n  // the end of the batch. This is needed to propagate errors correctly if a\n  // subtree fails more than once.\n  let failedBoundaries: Set<Fiber> | null = null;\n  // Error boundaries that captured an error during the current commit.\n  let commitPhaseBoundaries: Set<Fiber> | null = null;\n  let firstUncaughtError: Error | null = null;\n  let fatalError: Error | null = null;\n\n  let isCommitting: boolean = false;\n  let isUnmounting: boolean = false;\n\n  function scheduleAnimationCallback(callback) {\n    if (!isAnimationCallbackScheduled) {\n      isAnimationCallbackScheduled = true;\n      hostScheduleAnimationCallback(callback);\n    }\n  }\n\n  function scheduleDeferredCallback(callback) {\n    if (!isDeferredCallbackScheduled) {\n      isDeferredCallbackScheduled = true;\n      hostScheduleDeferredCallback(callback);\n    }\n  }\n\n  function resetContextStack() {\n    // Reset the stack\n    reset();\n    // Reset the cursors\n    resetContext();\n    resetHostContainer();\n  }\n\n  // findNextUnitOfWork mutates the current priority context. It is reset after\n  // after the workLoop exits, so never call findNextUnitOfWork from outside\n  // the work loop.\n  function findNextUnitOfWork() {\n    // Clear out roots with no more work on them, or if they have uncaught errors\n    while (\n      nextScheduledRoot !== null &&\n      nextScheduledRoot.current.pendingWorkPriority === NoWork\n    ) {\n      // Unschedule this root.\n      nextScheduledRoot.isScheduled = false;\n      // Read the next pointer now.\n      // We need to clear it in case this root gets scheduled again later.\n      const next = nextScheduledRoot.nextScheduledRoot;\n      nextScheduledRoot.nextScheduledRoot = null;\n      // Exit if we cleared all the roots and there's no work to do.\n      if (nextScheduledRoot === lastScheduledRoot) {\n        nextScheduledRoot = null;\n        lastScheduledRoot = null;\n        nextPriorityLevel = NoWork;\n        return null;\n      }\n      // Continue with the next root.\n      // If there's no work on it, it will get unscheduled too.\n      nextScheduledRoot = next;\n    }\n\n    let root = nextScheduledRoot;\n    let highestPriorityRoot = null;\n    let highestPriorityLevel = NoWork;\n    while (root !== null) {\n      if (\n        root.current.pendingWorkPriority !== NoWork &&\n        (highestPriorityLevel === NoWork ||\n          highestPriorityLevel > root.current.pendingWorkPriority)\n      ) {\n        highestPriorityLevel = root.current.pendingWorkPriority;\n        highestPriorityRoot = root;\n      }\n      // We didn't find anything to do in this root, so let's try the next one.\n      root = root.nextScheduledRoot;\n    }\n    if (highestPriorityRoot !== null) {\n      nextPriorityLevel = highestPriorityLevel;\n      priorityContext = nextPriorityLevel;\n\n      // Before we start any new work, let's make sure that we have a fresh\n      // stack to work from.\n      // TODO: This call is buried a bit too deep. It would be nice to have\n      // a single point which happens right before any new work and\n      // unfortunately this is it.\n      resetContextStack();\n\n      return cloneFiber(highestPriorityRoot.current, highestPriorityLevel);\n    }\n\n    nextPriorityLevel = NoWork;\n    return null;\n  }\n\n  function commitAllHostEffects() {\n    while (nextEffect !== null) {\n      if (__DEV__) {\n        ReactDebugCurrentFiber.current = nextEffect;\n        recordEffect();\n      }\n\n      const effectTag = nextEffect.effectTag;\n      if (effectTag & ContentReset) {\n        config.resetTextContent(nextEffect.stateNode);\n      }\n\n      if (effectTag & Ref) {\n        const current = nextEffect.alternate;\n        if (current !== null) {\n          commitDetachRef(current);\n        }\n      }\n\n      // The following switch statement is only concerned about placement,\n      // updates, and deletions. To avoid needing to add a case for every\n      // possible bitmap value, we remove the secondary effects from the\n      // effect tag and switch on that value.\n      let primaryEffectTag = effectTag & ~(Callback | Err | ContentReset | Ref);\n      switch (primaryEffectTag) {\n        case Placement: {\n          commitPlacement(nextEffect);\n          // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n          // any life-cycles like componentDidMount gets called.\n          // TODO: findDOMNode doesn't rely on this any more but isMounted\n          // does and isMounted is deprecated anyway so we should be able\n          // to kill this.\n          nextEffect.effectTag &= ~Placement;\n          break;\n        }\n        case PlacementAndUpdate: {\n          // Placement\n          commitPlacement(nextEffect);\n          // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n          // any life-cycles like componentDidMount gets called.\n          nextEffect.effectTag &= ~Placement;\n\n          // Update\n          const current = nextEffect.alternate;\n          commitWork(current, nextEffect);\n          break;\n        }\n        case Update: {\n          const current = nextEffect.alternate;\n          commitWork(current, nextEffect);\n          break;\n        }\n        case Deletion: {\n          isUnmounting = true;\n          commitDeletion(nextEffect);\n          isUnmounting = false;\n          break;\n        }\n      }\n      nextEffect = nextEffect.nextEffect;\n    }\n\n    if (__DEV__) {\n      ReactDebugCurrentFiber.current = null;\n    }\n  }\n\n  function commitAllLifeCycles() {\n    while (nextEffect !== null) {\n      const effectTag = nextEffect.effectTag;\n\n      // Use Task priority for lifecycle updates\n      if (effectTag & (Update | Callback)) {\n        if (__DEV__) {\n          recordEffect();\n        }\n        const current = nextEffect.alternate;\n        commitLifeCycles(current, nextEffect);\n      }\n\n      if (effectTag & Ref) {\n        if (__DEV__) {\n          recordEffect();\n        }\n        commitAttachRef(nextEffect);\n      }\n\n      if (effectTag & Err) {\n        if (__DEV__) {\n          recordEffect();\n        }\n        commitErrorHandling(nextEffect);\n      }\n\n      const next = nextEffect.nextEffect;\n      // Ensure that we clean these up so that we don't accidentally keep them.\n      // I'm not actually sure this matters because we can't reset firstEffect\n      // and lastEffect since they're on every node, not just the effectful\n      // ones. So we have to clean everything as we reuse nodes anyway.\n      nextEffect.nextEffect = null;\n      // Ensure that we reset the effectTag here so that we can rely on effect\n      // tags to reason about the current life-cycle.\n      nextEffect = next;\n    }\n  }\n\n  function commitAllWork(finishedWork: Fiber) {\n    // We keep track of this so that captureError can collect any boundaries\n    // that capture an error during the commit phase. The reason these aren't\n    // local to this function is because errors that occur during cWU are\n    // captured elsewhere, to prevent the unmount from being interrupted.\n    isCommitting = true;\n    if (__DEV__) {\n      startCommitTimer();\n    }\n\n    pendingCommit = null;\n    const root: FiberRoot = (finishedWork.stateNode: any);\n    invariant(\n      root.current !== finishedWork,\n      'Cannot commit the same tree as before. This is probably a bug ' +\n        'related to the return field. This error is likely caused by a bug ' +\n        'in React. Please file an issue.',\n    );\n\n    // Reset this to null before calling lifecycles\n    ReactCurrentOwner.current = null;\n\n    // Updates that occur during the commit phase should have Task priority\n    const previousPriorityContext = priorityContext;\n    priorityContext = TaskPriority;\n\n    let firstEffect;\n    if (finishedWork.effectTag !== NoEffect) {\n      // A fiber's effect list consists only of its children, not itself. So if\n      // the root has an effect, we need to add it to the end of the list. The\n      // resulting list is the set that would belong to the root's parent, if\n      // it had one; that is, all the effects in the tree including the root.\n      if (finishedWork.lastEffect !== null) {\n        finishedWork.lastEffect.nextEffect = finishedWork;\n        firstEffect = finishedWork.firstEffect;\n      } else {\n        firstEffect = finishedWork;\n      }\n    } else {\n      // There is no effect on the root.\n      firstEffect = finishedWork.firstEffect;\n    }\n\n    const commitInfo = prepareForCommit();\n\n    // Commit all the side-effects within a tree. We'll do this in two passes.\n    // The first pass performs all the host insertions, updates, deletions and\n    // ref unmounts.\n    nextEffect = firstEffect;\n    if (__DEV__) {\n      startCommitHostEffectsTimer();\n    }\n    while (nextEffect !== null) {\n      let error = null;\n      if (__DEV__) {\n        error = invokeGuardedCallback(\n          null,\n          commitAllHostEffects,\n          null,\n          finishedWork,\n        );\n      } else {\n        try {\n          commitAllHostEffects(finishedWork);\n        } catch (e) {\n          error = e;\n        }\n      }\n      if (error !== null) {\n        invariant(\n          nextEffect !== null,\n          'Should have next effect. This error is likely caused by a bug ' +\n            'in React. Please file an issue.',\n        );\n        captureError(nextEffect, error);\n        // Clean-up\n        if (nextEffect !== null) {\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    }\n    if (__DEV__) {\n      stopCommitHostEffectsTimer();\n    }\n\n    resetAfterCommit(commitInfo);\n\n    // The work-in-progress tree is now the current tree. This must come after\n    // the first pass of the commit phase, so that the previous tree is still\n    // current during componentWillUnmount, but before the second pass, so that\n    // the finished work is current during componentDidMount/Update.\n    root.current = finishedWork;\n\n    // In the second pass we'll perform all life-cycles and ref callbacks.\n    // Life-cycles happen as a separate pass so that all placements, updates,\n    // and deletions in the entire tree have already been invoked.\n    // This pass also triggers any renderer-specific initial effects.\n    nextEffect = firstEffect;\n    if (__DEV__) {\n      startCommitLifeCyclesTimer();\n    }\n    while (nextEffect !== null) {\n      let error = null;\n      if (__DEV__) {\n        error = invokeGuardedCallback(\n          null,\n          commitAllLifeCycles,\n          null,\n          finishedWork,\n        );\n      } else {\n        try {\n          commitAllLifeCycles(finishedWork);\n        } catch (e) {\n          error = e;\n        }\n      }\n      if (error !== null) {\n        invariant(\n          nextEffect !== null,\n          'Should have next effect. This error is likely caused by a bug ' +\n            'in React. Please file an issue.',\n        );\n        captureError(nextEffect, error);\n        if (nextEffect !== null) {\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    }\n\n    isCommitting = false;\n    if (__DEV__) {\n      stopCommitLifeCyclesTimer();\n      stopCommitTimer();\n    }\n    if (typeof onCommitRoot === 'function') {\n      onCommitRoot(finishedWork.stateNode);\n    }\n    if (__DEV__ && ReactFiberInstrumentation.debugTool) {\n      ReactFiberInstrumentation.debugTool.onCommitWork(finishedWork);\n    }\n\n    // If we caught any errors during this commit, schedule their boundaries\n    // to update.\n    if (commitPhaseBoundaries) {\n      commitPhaseBoundaries.forEach(scheduleErrorRecovery);\n      commitPhaseBoundaries = null;\n    }\n\n    priorityContext = previousPriorityContext;\n  }\n\n  function resetWorkPriority(workInProgress: Fiber) {\n    let newPriority = NoWork;\n\n    // Check for pending update priority. This is usually null so it shouldn't\n    // be a perf issue.\n    const queue = workInProgress.updateQueue;\n    const tag = workInProgress.tag;\n    if (\n      queue !== null &&\n      // TODO: Revisit once updateQueue is typed properly to distinguish between\n      // update payloads for host components and update queues for composites\n      (tag === ClassComponent || tag === HostRoot)\n    ) {\n      newPriority = getPendingPriority(queue);\n    }\n\n    // TODO: Coroutines need to visit stateNode\n\n    // progressedChild is going to be the child set with the highest priority.\n    // Either it is the same as child, or it just bailed out because it choose\n    // not to do the work.\n    let child = workInProgress.progressedChild;\n    while (child !== null) {\n      // Ensure that remaining work priority bubbles up.\n      if (\n        child.pendingWorkPriority !== NoWork &&\n        (newPriority === NoWork || newPriority > child.pendingWorkPriority)\n      ) {\n        newPriority = child.pendingWorkPriority;\n      }\n      child = child.sibling;\n    }\n    workInProgress.pendingWorkPriority = newPriority;\n  }\n\n  function completeUnitOfWork(workInProgress: Fiber): Fiber | null {\n    while (true) {\n      // The current, flushed, state of this fiber is the alternate.\n      // Ideally nothing should rely on this, but relying on it here\n      // means that we don't need an additional field on the work in\n      // progress.\n      const current = workInProgress.alternate;\n      const next = completeWork(current, workInProgress);\n\n      const returnFiber = workInProgress.return;\n      const siblingFiber = workInProgress.sibling;\n\n      resetWorkPriority(workInProgress);\n\n      if (next !== null) {\n        if (__DEV__) {\n          stopWorkTimer(workInProgress);\n        }\n        if (__DEV__ && ReactFiberInstrumentation.debugTool) {\n          ReactFiberInstrumentation.debugTool.onCompleteWork(workInProgress);\n        }\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        return next;\n      }\n\n      if (returnFiber !== null) {\n        // Append all the effects of the subtree and this fiber onto the effect\n        // list of the parent. The completion order of the children affects the\n        // side-effect order.\n        if (returnFiber.firstEffect === null) {\n          returnFiber.firstEffect = workInProgress.firstEffect;\n        }\n        if (workInProgress.lastEffect !== null) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;\n          }\n          returnFiber.lastEffect = workInProgress.lastEffect;\n        }\n\n        // If this fiber had side-effects, we append it AFTER the children's\n        // side-effects. We can perform certain side-effects earlier if\n        // needed, by doing multiple passes over the effect list. We don't want\n        // to schedule our own side-effect on our own list because if end up\n        // reusing children we'll schedule this effect onto itself since we're\n        // at the end.\n        if (workInProgress.effectTag !== NoEffect) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress;\n          } else {\n            returnFiber.firstEffect = workInProgress;\n          }\n          returnFiber.lastEffect = workInProgress;\n        }\n      }\n\n      if (__DEV__) {\n        stopWorkTimer(workInProgress);\n      }\n      if (__DEV__ && ReactFiberInstrumentation.debugTool) {\n        ReactFiberInstrumentation.debugTool.onCompleteWork(workInProgress);\n      }\n\n      if (siblingFiber !== null) {\n        // If there is more work to do in this returnFiber, do that next.\n        return siblingFiber;\n      } else if (returnFiber !== null) {\n        // If there's no more work in this returnFiber. Complete the returnFiber.\n        workInProgress = returnFiber;\n        continue;\n      } else {\n        // We've reached the root. Unless we're current performing deferred\n        // work, we should commit the completed work immediately. If we are\n        // performing deferred work, returning null indicates to the caller\n        // that we just completed the root so they can handle that case correctly.\n        if (nextPriorityLevel < HighPriority) {\n          // Otherwise, we should commit immediately.\n          commitAllWork(workInProgress);\n        } else {\n          pendingCommit = workInProgress;\n        }\n        return null;\n      }\n    }\n\n    // Without this explicit null return Flow complains of invalid return type\n    return null;\n  }\n\n  function performUnitOfWork(workInProgress: Fiber): Fiber | null {\n    // The current, flushed, state of this fiber is the alternate.\n    // Ideally nothing should rely on this, but relying on it here\n    // means that we don't need an additional field on the work in\n    // progress.\n    const current = workInProgress.alternate;\n\n    // See if beginning this work spawns more work.\n    if (__DEV__) {\n      startWorkTimer(workInProgress);\n    }\n    let next = beginWork(current, workInProgress, nextPriorityLevel);\n    if (__DEV__ && ReactFiberInstrumentation.debugTool) {\n      ReactFiberInstrumentation.debugTool.onBeginWork(workInProgress);\n    }\n\n    if (next === null) {\n      // If this doesn't spawn new work, complete the current work.\n      next = completeUnitOfWork(workInProgress);\n    }\n\n    ReactCurrentOwner.current = null;\n    if (__DEV__) {\n      ReactDebugCurrentFiber.current = null;\n    }\n\n    return next;\n  }\n\n  function performFailedUnitOfWork(workInProgress: Fiber): Fiber | null {\n    // The current, flushed, state of this fiber is the alternate.\n    // Ideally nothing should rely on this, but relying on it here\n    // means that we don't need an additional field on the work in\n    // progress.\n    const current = workInProgress.alternate;\n\n    // See if beginning this work spawns more work.\n    if (__DEV__) {\n      startWorkTimer(workInProgress);\n    }\n    let next = beginFailedWork(current, workInProgress, nextPriorityLevel);\n    if (__DEV__ && ReactFiberInstrumentation.debugTool) {\n      ReactFiberInstrumentation.debugTool.onBeginWork(workInProgress);\n    }\n\n    if (next === null) {\n      // If this doesn't spawn new work, complete the current work.\n      next = completeUnitOfWork(workInProgress);\n    }\n\n    ReactCurrentOwner.current = null;\n    if (__DEV__) {\n      ReactDebugCurrentFiber.current = null;\n    }\n\n    return next;\n  }\n\n  function performDeferredWork(deadline) {\n    // We pass the lowest deferred priority here because it acts as a minimum.\n    // Higher priorities will also be performed.\n    isDeferredCallbackScheduled = false;\n    performWork(OffscreenPriority, deadline);\n  }\n\n  function performAnimationWork() {\n    isAnimationCallbackScheduled = false;\n    performWork(AnimationPriority, null);\n  }\n\n  function clearErrors() {\n    if (nextUnitOfWork === null) {\n      nextUnitOfWork = findNextUnitOfWork();\n    }\n    // Keep performing work until there are no more errors\n    while (\n      capturedErrors !== null &&\n      capturedErrors.size &&\n      nextUnitOfWork !== null &&\n      nextPriorityLevel !== NoWork &&\n      nextPriorityLevel <= TaskPriority\n    ) {\n      if (hasCapturedError(nextUnitOfWork)) {\n        // Use a forked version of performUnitOfWork\n        nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);\n      } else {\n        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n      }\n      if (nextUnitOfWork === null) {\n        // If performUnitOfWork returns null, that means we just committed\n        // a root. Normally we'd need to clear any errors that were scheduled\n        // during the commit phase. But we're already clearing errors, so\n        // we can continue.\n        nextUnitOfWork = findNextUnitOfWork();\n      }\n    }\n  }\n\n  function workLoop(priorityLevel, deadline: Deadline | null) {\n    // Clear any errors.\n    clearErrors();\n\n    if (nextUnitOfWork === null) {\n      nextUnitOfWork = findNextUnitOfWork();\n    }\n\n    let hostRootTimeMarker;\n    if (\n      ReactFeatureFlags.logTopLevelRenders &&\n      nextUnitOfWork !== null &&\n      nextUnitOfWork.tag === HostRoot &&\n      nextUnitOfWork.child !== null\n    ) {\n      const componentName = getComponentName(nextUnitOfWork.child) || '';\n      hostRootTimeMarker = 'React update: ' + componentName;\n      console.time(hostRootTimeMarker);\n    }\n\n    // If there's a deadline, and we're not performing Task work, perform work\n    // using this loop that checks the deadline on every iteration.\n    if (deadline !== null && priorityLevel > TaskPriority) {\n      // The deferred work loop will run until there's no time left in\n      // the current frame.\n      while (nextUnitOfWork !== null && !deadlineHasExpired) {\n        if (deadline.timeRemaining() > timeHeuristicForUnitOfWork) {\n          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n          // In a deferred work batch, iff nextUnitOfWork returns null, we just\n          // completed a root and a pendingCommit exists. Logically, we could\n          // omit either of the checks in the following condition, but we need\n          // both to satisfy Flow.\n          if (nextUnitOfWork === null && pendingCommit !== null) {\n            // If we have time, we should commit the work now.\n            if (deadline.timeRemaining() > timeHeuristicForUnitOfWork) {\n              commitAllWork(pendingCommit);\n              nextUnitOfWork = findNextUnitOfWork();\n              // Clear any errors that were scheduled during the commit phase.\n              clearErrors();\n            } else {\n              deadlineHasExpired = true;\n            }\n            // Otherwise the root will committed in the next frame.\n          }\n        } else {\n          deadlineHasExpired = true;\n        }\n      }\n    } else {\n      // If there's no deadline, or if we're performing Task work, use this loop\n      // that doesn't check how much time is remaining. It will keep running\n      // until we run out of work at this priority level.\n      while (\n        nextUnitOfWork !== null &&\n        nextPriorityLevel !== NoWork &&\n        nextPriorityLevel <= priorityLevel\n      ) {\n        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n        if (nextUnitOfWork === null) {\n          nextUnitOfWork = findNextUnitOfWork();\n          // performUnitOfWork returned null, which means we just committed a\n          // root. Clear any errors that were scheduled during the commit phase.\n          clearErrors();\n        }\n      }\n    }\n\n    if (hostRootTimeMarker) {\n      console.timeEnd(hostRootTimeMarker);\n    }\n  }\n\n  function performWork(\n    priorityLevel: PriorityLevel,\n    deadline: Deadline | null,\n  ) {\n    if (__DEV__) {\n      startWorkLoopTimer();\n    }\n\n    invariant(\n      !isPerformingWork,\n      'performWork was called recursively. This error is likely caused ' +\n        'by a bug in React. Please file an issue.',\n    );\n    isPerformingWork = true;\n    const isPerformingDeferredWork = !!deadline;\n\n    // This outer loop exists so that we can restart the work loop after\n    // catching an error. It also lets us flush Task work at the end of a\n    // deferred batch.\n    while (priorityLevel !== NoWork && !fatalError) {\n      invariant(\n        deadline !== null || priorityLevel < HighPriority,\n        'Cannot perform deferred work without a deadline. This error is ' +\n          'likely caused by a bug in React. Please file an issue.',\n      );\n\n      // Before starting any work, check to see if there are any pending\n      // commits from the previous frame.\n      if (pendingCommit !== null && !deadlineHasExpired) {\n        commitAllWork(pendingCommit);\n      }\n\n      // Nothing in performWork should be allowed to throw. All unsafe\n      // operations must happen within workLoop, which is extracted to a\n      // separate function so that it can be optimized by the JS engine.\n      priorityContextBeforeReconciliation = priorityContext;\n      let error = null;\n      if (__DEV__) {\n        error = invokeGuardedCallback(\n          null,\n          workLoop,\n          null,\n          priorityLevel,\n          deadline,\n        );\n      } else {\n        try {\n          workLoop(priorityLevel, deadline);\n        } catch (e) {\n          error = e;\n        }\n      }\n      // Reset the priority context to its value before reconcilation.\n      priorityContext = priorityContextBeforeReconciliation;\n\n      if (error !== null) {\n        // We caught an error during either the begin or complete phases.\n        const failedWork = nextUnitOfWork;\n\n        if (failedWork !== null) {\n          // \"Capture\" the error by finding the nearest boundary. If there is no\n          // error boundary, the nearest host container acts as one. If\n          // captureError returns null, the error was intentionally ignored.\n          const maybeBoundary = captureError(failedWork, error);\n          if (maybeBoundary !== null) {\n            const boundary = maybeBoundary;\n\n            // Complete the boundary as if it rendered null. This will unmount\n            // the failed tree.\n            beginFailedWork(boundary.alternate, boundary, priorityLevel);\n\n            // The next unit of work is now the boundary that captured the error.\n            // Conceptually, we're unwinding the stack. We need to unwind the\n            // context stack, too, from the failed work to the boundary that\n            // captured the error.\n            // TODO: If we set the memoized props in beginWork instead of\n            // completeWork, rather than unwind the stack, we can just restart\n            // from the root. Can't do that until then because without memoized\n            // props, the nodes higher up in the tree will rerender unnecessarily.\n            unwindContexts(failedWork, boundary);\n            nextUnitOfWork = completeUnitOfWork(boundary);\n          }\n          // Continue performing work\n          continue;\n        } else if (fatalError === null) {\n          // There is no current unit of work. This is a worst-case scenario\n          // and should only be possible if there's a bug in the renderer, e.g.\n          // inside resetAfterCommit.\n          fatalError = error;\n        }\n      }\n\n      // Stop performing work\n      priorityLevel = NoWork;\n\n      // If have we more work, and we're in a deferred batch, check to see\n      // if the deadline has expired.\n      if (\n        nextPriorityLevel !== NoWork &&\n        isPerformingDeferredWork &&\n        !deadlineHasExpired\n      ) {\n        // We have more time to do work.\n        priorityLevel = nextPriorityLevel;\n        continue;\n      }\n\n      // There might be work left. Depending on the priority, we should\n      // either perform it now or schedule a callback to perform it later.\n      switch (nextPriorityLevel) {\n        case SynchronousPriority:\n        case TaskPriority:\n          // Perform work immediately by switching the priority level\n          // and continuing the loop.\n          priorityLevel = nextPriorityLevel;\n          break;\n        case AnimationPriority:\n          scheduleAnimationCallback(performAnimationWork);\n          // Even though the next unit of work has animation priority, there\n          // may still be deferred work left over as well. I think this is\n          // only important for unit tests. In a real app, a deferred callback\n          // would be scheduled during the next animation frame.\n          scheduleDeferredCallback(performDeferredWork);\n          break;\n        case HighPriority:\n        case LowPriority:\n        case OffscreenPriority:\n          scheduleDeferredCallback(performDeferredWork);\n          break;\n      }\n    }\n\n    const errorToThrow = fatalError || firstUncaughtError;\n\n    // We're done performing work. Time to clean up.\n    isPerformingWork = false;\n    deadlineHasExpired = false;\n    fatalError = null;\n    firstUncaughtError = null;\n    capturedErrors = null;\n    failedBoundaries = null;\n    if (__DEV__) {\n      stopWorkLoopTimer();\n    }\n\n    // It's safe to throw any unhandled errors.\n    if (errorToThrow !== null) {\n      throw errorToThrow;\n    }\n  }\n\n  // Returns the boundary that captured the error, or null if the error is ignored\n  function captureError(failedWork: Fiber, error: Error): Fiber | null {\n    // It is no longer valid because we exited the user code.\n    ReactCurrentOwner.current = null;\n    if (__DEV__) {\n      ReactDebugCurrentFiber.current = null;\n      ReactDebugCurrentFiber.phase = null;\n    }\n    // It is no longer valid because this unit of work failed.\n    nextUnitOfWork = null;\n\n    // Search for the nearest error boundary.\n    let boundary: Fiber | null = null;\n\n    // Passed to logCapturedError()\n    let errorBoundaryFound: boolean = false;\n    let willRetry: boolean = false;\n    let errorBoundaryName: string | null = null;\n\n    // Host containers are a special case. If the failed work itself is a host\n    // container, then it acts as its own boundary. In all other cases, we\n    // ignore the work itself and only search through the parents.\n    if (failedWork.tag === HostRoot) {\n      boundary = failedWork;\n\n      if (isFailedBoundary(failedWork)) {\n        // If this root already failed, there must have been an error when\n        // attempting to unmount it. This is a worst-case scenario and\n        // should only be possible if there's a bug in the renderer.\n        fatalError = error;\n      }\n    } else {\n      let node = failedWork.return;\n      while (node !== null && boundary === null) {\n        if (node.tag === ClassComponent) {\n          const instance = node.stateNode;\n          if (typeof instance.unstable_handleError === 'function') {\n            errorBoundaryFound = true;\n            errorBoundaryName = getComponentName(node);\n\n            // Found an error boundary!\n            boundary = node;\n            willRetry = true;\n          }\n        } else if (node.tag === HostRoot) {\n          // Treat the root like a no-op error boundary.\n          boundary = node;\n        }\n\n        if (isFailedBoundary(node)) {\n          // This boundary is already in a failed state.\n\n          // If we're currently unmounting, that means this error was\n          // thrown while unmounting a failed subtree. We should ignore\n          // the error.\n          if (isUnmounting) {\n            return null;\n          }\n\n          // If we're in the commit phase, we should check to see if\n          // this boundary already captured an error during this commit.\n          // This case exists because multiple errors can be thrown during\n          // a single commit without interruption.\n          if (\n            commitPhaseBoundaries !== null &&\n            (commitPhaseBoundaries.has(node) ||\n              (node.alternate !== null &&\n                commitPhaseBoundaries.has(node.alternate)))\n          ) {\n            // If so, we should ignore this error.\n            return null;\n          }\n\n          // The error should propagate to the next boundary - we keep looking.\n          boundary = null;\n          willRetry = false;\n        }\n\n        node = node.return;\n      }\n    }\n\n    if (boundary !== null) {\n      // Add to the collection of failed boundaries. This lets us know that\n      // subsequent errors in this subtree should propagate to the next boundary.\n      if (failedBoundaries === null) {\n        failedBoundaries = new Set();\n      }\n      failedBoundaries.add(boundary);\n\n      // This method is unsafe outside of the begin and complete phases.\n      // We might be in the commit phase when an error is captured.\n      // The risk is that the return path from this Fiber may not be accurate.\n      // That risk is acceptable given the benefit of providing users more context.\n      const componentStack = getStackAddendumByWorkInProgressFiber(failedWork);\n      const componentName = getComponentName(failedWork);\n\n      // Add to the collection of captured errors. This is stored as a global\n      // map of errors and their component stack location keyed by the boundaries\n      // that capture them. We mostly use this Map as a Set; it's a Map only to\n      // avoid adding a field to Fiber to store the error.\n      if (capturedErrors === null) {\n        capturedErrors = new Map();\n      }\n      capturedErrors.set(boundary, {\n        componentName,\n        componentStack,\n        error,\n        errorBoundary: errorBoundaryFound ? boundary.stateNode : null,\n        errorBoundaryFound,\n        errorBoundaryName,\n        willRetry,\n      });\n\n      // If we're in the commit phase, defer scheduling an update on the\n      // boundary until after the commit is complete\n      if (isCommitting) {\n        if (commitPhaseBoundaries === null) {\n          commitPhaseBoundaries = new Set();\n        }\n        commitPhaseBoundaries.add(boundary);\n      } else {\n        // Otherwise, schedule an update now.\n        scheduleErrorRecovery(boundary);\n      }\n      return boundary;\n    } else if (firstUncaughtError === null) {\n      // If no boundary is found, we'll need to throw the error\n      firstUncaughtError = error;\n    }\n    return null;\n  }\n\n  function hasCapturedError(fiber: Fiber): boolean {\n    // TODO: capturedErrors should store the boundary instance, to avoid needing\n    // to check the alternate.\n    return capturedErrors !== null &&\n      (capturedErrors.has(fiber) ||\n        (fiber.alternate !== null && capturedErrors.has(fiber.alternate)));\n  }\n\n  function isFailedBoundary(fiber: Fiber): boolean {\n    // TODO: failedBoundaries should store the boundary instance, to avoid\n    // needing to check the alternate.\n    return failedBoundaries !== null &&\n      (failedBoundaries.has(fiber) ||\n        (fiber.alternate !== null && failedBoundaries.has(fiber.alternate)));\n  }\n\n  function commitErrorHandling(effectfulFiber: Fiber) {\n    let capturedError;\n    if (capturedErrors !== null) {\n      capturedError = capturedErrors.get(effectfulFiber);\n      capturedErrors.delete(effectfulFiber);\n      if (capturedError == null) {\n        if (effectfulFiber.alternate !== null) {\n          effectfulFiber = effectfulFiber.alternate;\n          capturedError = capturedErrors.get(effectfulFiber);\n          capturedErrors.delete(effectfulFiber);\n        }\n      }\n    }\n\n    invariant(\n      capturedError != null,\n      'No error for given unit of work. This error is likely caused by a ' +\n        'bug in React. Please file an issue.',\n    );\n\n    const error = capturedError.error;\n    try {\n      logCapturedError(capturedError);\n    } catch (e) {\n      // Prevent cycle if logCapturedError() throws.\n      // A cycle may still occur if logCapturedError renders a component that throws.\n      console.error(e);\n    }\n\n    switch (effectfulFiber.tag) {\n      case ClassComponent:\n        const instance = effectfulFiber.stateNode;\n\n        const info: HandleErrorInfo = {\n          componentStack: capturedError.componentStack,\n        };\n\n        // Allow the boundary to handle the error, usually by scheduling\n        // an update to itself\n        instance.unstable_handleError(error, info);\n        return;\n      case HostRoot:\n        if (firstUncaughtError === null) {\n          // If this is the host container, we treat it as a no-op error\n          // boundary. We'll throw the first uncaught error once it's safe to\n          // do so, at the end of the batch.\n          firstUncaughtError = error;\n        }\n        return;\n      default:\n        invariant(\n          false,\n          'Invalid type of work. This error is likely caused by a bug in ' +\n            'React. Please file an issue.',\n        );\n    }\n  }\n\n  function unwindContexts(from: Fiber, to: Fiber) {\n    let node = from;\n    while (node !== null && node !== to && node.alternate !== to) {\n      switch (node.tag) {\n        case ClassComponent:\n          popContextProvider(node);\n          break;\n        case HostComponent:\n          popHostContext(node);\n          break;\n        case HostRoot:\n          popHostContainer(node);\n          break;\n        case HostPortal:\n          popHostContainer(node);\n          break;\n      }\n      if (__DEV__) {\n        stopWorkTimer(node);\n      }\n      node = node.return;\n    }\n  }\n\n  function scheduleRoot(root: FiberRoot, priorityLevel: PriorityLevel) {\n    if (priorityLevel === NoWork) {\n      return;\n    }\n\n    if (!root.isScheduled) {\n      root.isScheduled = true;\n      if (lastScheduledRoot) {\n        // Schedule ourselves to the end.\n        lastScheduledRoot.nextScheduledRoot = root;\n        lastScheduledRoot = root;\n      } else {\n        // We're the only work scheduled.\n        nextScheduledRoot = root;\n        lastScheduledRoot = root;\n      }\n    }\n  }\n\n  function scheduleUpdate(fiber: Fiber, priorityLevel: PriorityLevel) {\n    if (__DEV__) {\n      recordScheduleUpdate();\n    }\n\n    if (priorityLevel <= nextPriorityLevel) {\n      // We must reset the current unit of work pointer so that we restart the\n      // search from the root during the next tick, in case there is now higher\n      // priority work somewhere earlier than before.\n      nextUnitOfWork = null;\n    }\n\n    if (__DEV__) {\n      if (fiber.tag === ClassComponent) {\n        const instance = fiber.stateNode;\n        warnAboutInvalidUpdates(instance);\n      }\n    }\n\n    let node = fiber;\n    let shouldContinue = true;\n    while (node !== null && shouldContinue) {\n      // Walk the parent path to the root and update each node's priority. Once\n      // we reach a node whose priority matches (and whose alternate's priority\n      // matches) we can exit safely knowing that the rest of the path is correct.\n      shouldContinue = false;\n      if (\n        node.pendingWorkPriority === NoWork ||\n        node.pendingWorkPriority > priorityLevel\n      ) {\n        // Priority did not match. Update and keep going.\n        shouldContinue = true;\n        node.pendingWorkPriority = priorityLevel;\n      }\n      if (node.alternate !== null) {\n        if (\n          node.alternate.pendingWorkPriority === NoWork ||\n          node.alternate.pendingWorkPriority > priorityLevel\n        ) {\n          // Priority did not match. Update and keep going.\n          shouldContinue = true;\n          node.alternate.pendingWorkPriority = priorityLevel;\n        }\n      }\n      if (node.return === null) {\n        if (node.tag === HostRoot) {\n          const root: FiberRoot = (node.stateNode: any);\n          scheduleRoot(root, priorityLevel);\n          // Depending on the priority level, either perform work now or\n          // schedule a callback to perform work later.\n          switch (priorityLevel) {\n            case SynchronousPriority:\n              performWork(SynchronousPriority, null);\n              return;\n            case TaskPriority:\n              // TODO: If we're not already performing work, schedule a\n              // deferred callback.\n              return;\n            case AnimationPriority:\n              scheduleAnimationCallback(performAnimationWork);\n              return;\n            case HighPriority:\n            case LowPriority:\n            case OffscreenPriority:\n              scheduleDeferredCallback(performDeferredWork);\n              return;\n          }\n        } else {\n          if (__DEV__) {\n            if (fiber.tag === ClassComponent) {\n              warnAboutUpdateOnUnmounted(fiber.stateNode);\n            }\n          }\n          return;\n        }\n      }\n      node = node.return;\n    }\n  }\n\n  function getPriorityContext(): PriorityLevel {\n    // If we're in a batch, or if we're already performing work, downgrade sync\n    // priority to task priority\n    if (\n      priorityContext === SynchronousPriority &&\n      (isPerformingWork || isBatchingUpdates)\n    ) {\n      return TaskPriority;\n    }\n    return priorityContext;\n  }\n\n  function scheduleErrorRecovery(fiber: Fiber) {\n    scheduleUpdate(fiber, TaskPriority);\n  }\n\n  function performWithPriority(priorityLevel: PriorityLevel, fn: Function) {\n    const previousPriorityContext = priorityContext;\n    priorityContext = priorityLevel;\n    try {\n      fn();\n    } finally {\n      priorityContext = previousPriorityContext;\n    }\n  }\n\n  function batchedUpdates<A, R>(fn: (a: A) => R, a: A): R {\n    const previousIsBatchingUpdates = isBatchingUpdates;\n    isBatchingUpdates = true;\n    try {\n      return fn(a);\n    } finally {\n      isBatchingUpdates = previousIsBatchingUpdates;\n      // If we're not already inside a batch, we need to flush any task work\n      // that was created by the user-provided function.\n      if (!isPerformingWork && !isBatchingUpdates) {\n        performWork(TaskPriority, null);\n      }\n    }\n  }\n\n  function unbatchedUpdates<A>(fn: () => A): A {\n    const previousIsBatchingUpdates = isBatchingUpdates;\n    isBatchingUpdates = false;\n    try {\n      return fn();\n    } finally {\n      isBatchingUpdates = previousIsBatchingUpdates;\n    }\n  }\n\n  function syncUpdates<A>(fn: () => A): A {\n    const previousPriorityContext = priorityContext;\n    priorityContext = SynchronousPriority;\n    try {\n      return fn();\n    } finally {\n      priorityContext = previousPriorityContext;\n    }\n  }\n\n  function deferredUpdates<A>(fn: () => A): A {\n    const previousPriorityContext = priorityContext;\n    priorityContext = LowPriority;\n    try {\n      return fn();\n    } finally {\n      priorityContext = previousPriorityContext;\n    }\n  }\n\n  return {\n    scheduleUpdate: scheduleUpdate,\n    getPriorityContext: getPriorityContext,\n    performWithPriority: performWithPriority,\n    batchedUpdates: batchedUpdates,\n    unbatchedUpdates: unbatchedUpdates,\n    syncUpdates: syncUpdates,\n    deferredUpdates: deferredUpdates,\n  };\n};\n"]}]